from PIL import Image
import math
import numpy
import traceback

from image import ImageUtils
from image.ImageUtils import merge_images
from noise.NoiseGenerator import NoiseGenerator


class ImageGenerator:
    def __init__(self, dimensions=(64, 64)):
        self.image = Image.new(mode="RGB", size=dimensions)

    def populate_image(self, noise_array, debug=False):
        """Takes a noise array generated by FNS and populates an image with it.
        Feel free to extend this class and implement different algorithms to do this."""

        if debug:
            print(f'Noise array dim [0] {noise_array.shape[0]} [1] {noise_array.shape[1]} ' +
                  f'Image dim [0] {self.image.size[0]} I[1] {self.image.size[1]}')

        if not noise_array.ndim == 2:
            print("Noise supplied must be 2 dimensional.")
            raise Exception

        if not ((self.image.size[0] % noise_array.shape[0] == 0) and (self.image.size[1] % noise_array.shape[1] == 0)):
            print("Dimensions of supplied noise must multiply into image size.")
            raise Exception

        trans_mult_x = self.image.size[0] // noise_array.shape[0]
        trans_mult_y = self.image.size[1] // noise_array.shape[1]
        working_image = self.image.copy()
        pixels = working_image.load()

        r_lambda = lambda n, custom_arrays, x, y: (math.sqrt((custom_arrays[0][x, y] ** -1) + ((n * 255) ** 2)) % 255)

        r_array, g_array, b_array = ImageUtils.get_custom_arrays_from_noise([noise_array],
                [0,
                 0,
                 r_lambda])

        for x in range(self.image.size[0]):
            for y in range(self.image.size[1]):
                try:
                    r = r_array[x // trans_mult_x, y // trans_mult_y]
                    g = g_array[x // trans_mult_x, y // trans_mult_y]
                    b = b_array[x // trans_mult_x, y // trans_mult_y]
                    pixels[x, y] = (r, g, b)
                except Exception as e:
                    traceback.print_exception(e)
        self.image = working_image
        return working_image

    def generate_mosaic(self, seed=1, noise_generator=NoiseGenerator(), mosaic_side_length=3, dimensions=0):
        """Generates a mosaic of multiple images generated with the given parameters.
            Inputs: seed (int32)
                noise generator
                mosaic side length (side length of mosaic .-.)
                dimensions (dimensions of noise used to generate each image

                Dimensions of each image are set to size of this imagegenerator
            Outputs:
                Image. Also stored in self.image"""
        if not dimensions:
            dimensions = self.image.size
        image_list = []
        for i in range(mosaic_side_length ** 2):
            image_list.append(self.populate_image(noise_generator.get_noise(dimensions=dimensions,seed=i*seed)))
        self.image = merge_images(image_list, mosaic_side_length=mosaic_side_length)
        return self.image.copy()